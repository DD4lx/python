## 持久化的方式：
1、文件操作（读写文件）
2、数据库
3、云存储


## 两大类型数据库：
>关系型数据库（二维表）- MySQL
 - 扩展硬件 - 垂直扩展
 - 增加服务器，节点 - 水平扩展有前提（负载均衡）
 - 阿里 - 去IOE运动 - 去掉IBM小型机、去掉Oracle数据库、去掉EMC存储设备
>非关系型数据库（NoSQL数据库）
 - Redis - 高速缓存（键值对）
 - MongoDB - 文档数据（数据体量大价值低）
 - ElasticSearch - 搜索引擎（全文搜索）

>一些常见的单词缩写：
- Database - DB - 数据库(一堆文件)
- DBMS - Database Management System - 数据库管理系统（一套软件，例如，MySQL）
- DBA - Database Administrator - 人
- DBS - Database System - 前面3个组成一个数据库系统


- 在命令行输入help data types命令:可以查看有哪些数据类型
- 输入help/? int:可以查看数据类型的用法；
- help/? :查看帮助；不能在工具里面使用；必须在MySQL自带的命令行界面


>图形化的MySQL客户端工具
  - Navicat for MySQL（猫）
  - Toad for MySQL（蛤蟆）
  - SQLyog (海豚)



>E-R实体关系图
- 多对多关系无法靠一张表建立多对多关系；
需要再建一张表作文中间表来实现；
>建表时常设置的一些属性：
- charset utf8mb4 支持img字符；
- collate 指定默认的排序规则；
- engine 指定的默认引擎；innodb支持高并发的开发，支持事       务操作；
- comment：定义列的时候加上comment，sql语句注释；可以在设计里看见注释；
- decimal：小数；
- utf8_bin_ci:不区分大小写
- utf8_bin:区分大小写
>查询时常用的方法：
- distinct：SQL自带的去重函数
- SQL聚合函数：都支持；
- max()/min()/sum()/avg()/count()
- 不会考虑空值，空值加什么都是空值；
- group by 分组查询；
- having关键字，写在分组以后进行筛选；分组之前用where；
- 查询的东西来自多张表，通过连接查询，写连接条件实现
先写连表条件，再写筛选条件；
- inner join t1 on 连表条件(内连接查询方式)；

## 关系型数据库保证了数据的完整性、数据的一致性

>数据的完整性：
 - 实体完整性：每一条记录都是独一无二的，没有冗余的；
         依靠主键、唯一索引（唯一约束）来保证的；
 - 参照完整性：B表参照了A表，A表没有的记录在B表中决不能出现；
         依靠外键来保证；

   - 实现1对多：就使用添加外键；
   - 实现1对1：在添加了外键的情况下，再对列添加唯一约束/索引；
   - 实现多对多：新建一张表，添加包含对两种表的外键约束，如果要实现两列不能出现相同记录的情况，例如，同一学生，不能选择一门课选择了多次，此时，可以添加唯一约束来约束着两列（alter table tb_score add constraint uni_score_sid_cid unique (sid, cid);）

 - 域完整性：录入的数据都是有效的
         依靠数据类型，非空约束，默认值约束，检查约束（MySQL不支持）check(score between 0 and 100);成绩在0到100之间；来保证
>数据的一致性（事务） - 底层有锁的机制

- 一个事务包含多个操作，要么全都成功，要么全失败；
- 事务的四大特性：ACID特性
- Atomicity 原子性 - 不可分割（将多个操作看做一个整体）
- Consistency 一致性 - 事务前后数据状态一致
- Isolation 隔离性 - 多个事务不能看到彼此的中间状态
- Duration 持久性 - 事务完成后数据要持久化

>在出现并发事务访问数据的时候，数据库底层有锁机制来保护数据但是通常我们在写SQL的时候不用显示的书写锁操作;

>但是需要我们设定事务隔离级别，数据库会根据我们设定的事务隔离级别自动的数据加锁

- 并发数据访问可能出现的5种问题
- 第1类丢失更新
- 第2类丢失更新
- 脏读（读脏数据） - 一个事务读取到了另一个事务尚未提交		          的数据
- 不可重复读 - 一个事务在读取查询结果时发现其他事务更新	     	    了数据导致无法读取
- 幻读 - 一个事务在执行查询时发现被其他事务提交了新的数       据

>四种隔离级别：
- Read Uncommitted
- Read Committed 避免脏数据
- Repeatable Read 避免不可重复读
- Serializable 避免幻读-串行化

**注意：隔离级别越高，性能越差；**

>在MySQL中@@表示全局变量，@表示局部。临时变量
- select @@tx_isolation; - 查询事务隔离级别
- set session transaction isolation level read committed; - 设置事务隔离级别

















































